// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Unix = require("bs-platform/lib/js/unix.js");
var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function execSync(cmd, onOut, param) {
  var chan = Unix.open_process_in(cmd);
  try {
    var loop = function (param) {
      var line;
      try {
        line = Pervasives.input_line(chan);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.end_of_file) {
          return /* [] */0;
        }
        throw exn;
      }
      if (onOut !== undefined) {
        Curry._1(onOut, line);
      }
      return /* :: */[
              line,
              loop(undefined)
            ];
    };
    var lines = loop(undefined);
    var match = Unix.close_process_in(chan);
    switch (match.tag | 0) {
      case /* WEXITED */0 :
          if (match[0] !== 0) {
            return /* tuple */[
                    lines,
                    false
                  ];
          } else {
            return /* tuple */[
                    lines,
                    true
                  ];
          }
      case /* WSIGNALED */1 :
      case /* WSTOPPED */2 :
          return /* tuple */[
                  lines,
                  false
                ];
      
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.end_of_file) {
      return /* tuple */[
              /* [] */0,
              false
            ];
    }
    throw exn;
  }
}

function canRead(desc) {
  var match = Unix.select(/* :: */[
        desc,
        /* [] */0
      ], /* [] */0, /* [] */0, 0.01);
  return match[0] !== /* [] */0;
}

function exec(cmd, onOut) {
  var proc = Unix.open_process_in(cmd);
  var desc = Unix.descr_of_in_channel(proc);
  var buffer = Caml_bytes.caml_create_bytes(8192);
  var poll = function (param) {
    if (!canRead(desc)) {
      return ;
    }
    var read = Unix.read(desc, buffer, 0, 8192);
    var got = Bytes.sub_string(buffer, 0, read);
    if ($$String.trim(got).length !== 0) {
      return Curry._1(onOut, got);
    }
    
  };
  var close = function (param) {
    Unix.close_process_in(proc);
    
  };
  return /* tuple */[
          poll,
          close
        ];
}

function isAlive(pid) {
  var match = Unix.waitpid(/* :: */[
        /* WNOHANG */0,
        /* :: */[
          /* WUNTRACED */1,
          /* [] */0
        ]
      ], pid);
  return match[0] === 0;
}

function keepAlive(cmd, onOutOpt, onErrOpt, onStartOpt, checkIntervalOpt, param) {
  var onOut = onOutOpt !== undefined ? onOutOpt : (function (line) {
        
      });
  var onErr = onErrOpt !== undefined ? onErrOpt : (function (line) {
        
      });
  var onStart = onStartOpt !== undefined ? onStartOpt : (function (param) {
        
      });
  var checkInterval = checkIntervalOpt !== undefined ? checkIntervalOpt : 1;
  var buffer = Caml_bytes.caml_create_bytes(8192);
  var start = function (param) {
    Curry._1(onStart, undefined);
    var match = Unix.pipe(undefined, undefined);
    var match$1 = Unix.pipe(undefined, undefined);
    var match$2 = Unix.pipe(undefined, undefined);
    var pid = Unix.create_process("bash", [
          "bash",
          "-c",
          cmd
        ], match[0], match$1[1], match$2[1]);
    return /* tuple */[
            pid,
            match$1[0],
            match$2[0]
          ];
  };
  var $$process = {
    contents: start(undefined)
  };
  var lastCheck = {
    contents: Unix.gettimeofday(undefined)
  };
  var poll = function (param) {
    var match = $$process.contents;
    var err = match[2];
    var out = match[1];
    if (canRead(out)) {
      var read = Unix.read(out, buffer, 0, 8192);
      var got = Bytes.sub_string(buffer, 0, read);
      if ($$String.trim(got).length !== 0) {
        Curry._1(onOut, got);
      }
      
    }
    if (canRead(err)) {
      var read$1 = Unix.read(err, buffer, 0, 8192);
      var got$1 = Bytes.sub_string(buffer, 0, read$1);
      if ($$String.trim(got$1).length !== 0) {
        Curry._1(onErr, got$1);
      }
      
    }
    if (Unix.gettimeofday(undefined) - lastCheck.contents > checkInterval) {
      lastCheck.contents = Unix.gettimeofday(undefined);
      if (!isAlive(match[0])) {
        $$process.contents = start(undefined);
        return ;
      } else {
        return ;
      }
    }
    
  };
  var close = function (param) {
    var match = $$process.contents;
    return Unix.kill(match[0], 9);
  };
  return /* tuple */[
          poll,
          close
        ];
}

function poll(param) {
  return Curry._1(param[0], undefined);
}

function run(param) {
  var poll = param[0];
  while(true) {
    Curry._1(poll, undefined);
  };
  
}

function runAll(jobs) {
  while(true) {
    List.iter((function (f) {
            
          }), jobs);
  };
  
}

function kill(param) {
  return Curry._1(param[1], undefined);
}

exports.execSync = execSync;
exports.exec = exec;
exports.keepAlive = keepAlive;
exports.kill = kill;
exports.poll = poll;
exports.run = run;
exports.runAll = runAll;
/* Unix Not a pure module */
